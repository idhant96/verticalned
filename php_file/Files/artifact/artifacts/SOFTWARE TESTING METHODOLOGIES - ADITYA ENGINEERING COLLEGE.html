
<!-- saved from url=(0050)http://www.mcr.org.in/sureshmudunuri/stm/unit3.php -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>SOFTWARE TESTING METHODOLOGIES - ADITYA ENGINEERING COLLEGE</title>
<style type="text/css">
a 
{
text-decoration:none;
font-weight:bold;
color:#A00000;
font-family:Arial;
font-size:small;
}
a.head 
{
text-decoration:none;
font-weight:bold;
color:#FFFFFF;
font-family:Arial;
font-size: 13px;
}
.format 
{
text-decoration:none;
color:#A00000;
font-family:Arial;
font-size:small;
}
a.quick 
{
text-decoration:none;
font-weight:normal;
color:#FFFFFF;
font-family:palatino linotype,Arial;
font-size:12;
}
a:hover
{
color : blue;
font-weight:bold;
}

</style>
<link rel="stylesheet" type="text/css" href="./SOFTWARE TESTING METHODOLOGIES - ADITYA ENGINEERING COLLEGE_files/style.css">
</head>
<body bgcolor="#FFFFE0"><basefont face="palatino linotype">
<font face="Arial">
<a name="top"></a><table border="0" bordercolor="red" width="100%" cellspacing="5">
<tbody>

<tr><td>
<table border="0" bordercolor="red" width="100%"><!--This is starting table-->
<!-- #2fb260 -->
<tbody><tr><td bgcolor="#2E8B57" height="100">
<font size="5" color="white"></font><center><font size="5" color="white">Software Testing Methodologies Course Page</font><br>
<font size="2" color="white">R07 Regulation  - Dept. of CSE &amp; IT<br>Aditya Engineering College</font></center>
</td></tr>
<tr><td bgcolor="#2E8B57" align="center" width="100%" height="20"><table width="100%" border="0" cellpadding="0" cellspacing="0" align="center">
<tbody><tr>
	<td align="center"><p class="menu03"><a class="head" href="http://www.mcr.org.in/sureshmudunuri/stm/index.php">HOME</a></p></td>
	<td><img src="./SOFTWARE TESTING METHODOLOGIES - ADITYA ENGINEERING COLLEGE_files/menu01.gif" width="3" height="30" alt="" border="0"></td>
	<td align="center"><p class="menu03"><a class="head" href="http://www.mcr.org.in/sureshmudunuri/stm/schedule.php">SCHEDULE</a></p></td>
	<td><img src="./SOFTWARE TESTING METHODOLOGIES - ADITYA ENGINEERING COLLEGE_files/menu01.gif" width="3" height="30" alt="" border="0"></td>
	<td align="center"><p class="menu03"><a class="head" href="http://www.mcr.org.in/sureshmudunuri/stm/resources.php">RESOURCES</a></p></td>
	<td><img src="./SOFTWARE TESTING METHODOLOGIES - ADITYA ENGINEERING COLLEGE_files/menu01.gif" width="3" height="30" alt="" border="0"></td>
	<td align="center"><p class="menu03"><a class="head" href="http://www.mcr.org.in/sureshmudunuri/stm/glossary.php">GLOSSARY</a></p></td>
	<td><img src="./SOFTWARE TESTING METHODOLOGIES - ADITYA ENGINEERING COLLEGE_files/menu01.gif" width="3" height="30" alt="" border="0"></td>
	<td align="center"><p class="menu03"><a class="head" href="http://www.mcr.org.in/sureshmudunuri/stm/assignments.php">ASSIGNMENTS</a></p></td>
</tr>
</tbody></table>
</td>
</tr>

<tr><td valign="top">
<!-- CONTENT SECTION -->
<table border="0" width="100%" bgcolor="#2E8B57" cellpadding="2" cellspacing="2">

<tbody><tr><td width="15%" align="center" valign="top" bgcolor="#2E8B57"><br><a><b><u><i>QUICK LINKS</i></u></b></a>
  
<hr><b><font size="2"><a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/introduction.php">BRIEF OVERVIEW</a></font></b>  
<hr><a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit1.php">UNIT I</a><hr>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit1.php#testing_purpose">Purpose of Testing</a><br>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit1.php#dichotomies">Dichotomies</a><br>
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit1.php#testing_model">Model for Testing</a><br>
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit1.php#bug_consequences">Consequences of Bugs</a><br>
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit1.php#bug_taxonomy">Taxonomy of Bugs</a><br>
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit1.php#summary">Summary</a><br>
<hr><a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit2.php">UNIT II</a><hr>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit2.php#path_testing_basics">Basics of Path Testing</a><br>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit2.php#predicates">Predicates, Path Predicates and Achievable Paths</a><br>
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit2.php#path_sensitizing">Path Sensitizing</a><br>
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit2.php#path_instrumentation">Path Instrumentation</a><br>
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit2.php#path_testing_application">Application of Path Testing</a><br>
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit2.php#summary">Summary</a><br>
<hr><a class="quick" href="./SOFTWARE TESTING METHODOLOGIES - ADITYA ENGINEERING COLLEGE_files/SOFTWARE TESTING METHODOLOGIES - ADITYA ENGINEERING COLLEGE.html">UNIT III</a><hr>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit3.php#transaction_flows">Transaction Flows</a><br>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit3.php#transaction_flow_techniques">Transaction Flow Testing Techniques</a><br>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit3.php#transaction_implementation">Implementation</a><br>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit3.php#dataflow_testing_basics">Basics of Data Flow Testing</a><br>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit3.php#strategies_dft">Strategies in Data Flow Testing</a><br>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit3.php#application_dft">Application of Data Flow Testing</a><br>  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit3.php#summary">Summary</a><br>
<hr><a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit4.php">UNIT IV</a><hr>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit4.php#domains_paths">Domains and Paths</a><br>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit4.php#nice_ugly_domains">Nice and Ugly domains</a><br>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit4.php#domain_testing">Domain Testing</a><br>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit4.php#interface_testing">Domain and Interface Testing</a><br>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit4.php#domains_testability">Domains and Testability</a><br>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit4.php#summary">Summary</a><br>
<hr><a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit5.php">UNIT V</a><hr>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit5.php#path_products_expression">Path products and Path expression</a><br>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit5.php#reduction_procedure">Reduction Procedure</a><br>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit5.php#applications">Applications</a><br>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit5.php#regular_expressions">Regular Expressions and Flow Anomaly Detection</a><br>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit5.php#summary">Summary</a><br>
<hr><a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit6.php">UNIT VI</a><hr>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit6.php#logic_based_testing">Logic Based Testing</a><br>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit6.php#decision_tables">Decision Tables</a><br>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit6.php#path_expressions">Path Expressions</a><br>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit6.php#kv_charts">KV Charts</a><br>
  
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit6.php#specifications">Specifications</a><br>
<a class="quick" href="http://www.mcr.org.in/sureshmudunuri/stm/unit6.php#summary">Summary</a><br>
<hr><br><br><br><br>
 </td>
<td bgcolor="white" valign="top">
<table width="100%">
<tbody><tr><td bgcolor="#A0b260" align="center" width="100%" height="30"><b><a><font size="2">UNIT III - TRANSACTION FLOW TESTING AND DATA FLOW TESTING</font></a></b></td></tr>
</tbody></table>
<br>
<h4 class="section">TRANSACTION FLOW TESTING AND DATA FLOW TESTING:</h4>

<p align="justify">This unit gives an indepth overview of two forms of functional or system testing namely Transaction Flow Testing and Data Flow Testing.
</p>
<p align="justify">
<b>At the end of this unit, the student will be able to:</b>
</p><ul>
  <li>Understand the concept of transaction flow testing and data flow testing.</li>
  <li>Visualize the transaction flow and data flow in a software system.</li>
  <li>Understand the need and appreciate the usage of the two testing methods.</li>
  <li>Identify the complications in a transaction flow testing method and anomalies in data flow testing.</li>
  <li>Interpret the data flow anomaly state graphs and control flow grpahs and represent the state of the data objetcs.</li>
  <li>Understand the limitations of Static analysis in data flow testing.</li>
  <li>Compare and analyze various strategies of data flow testing.</li>
</ul>
<p></p>

<a name="transaction_flows"></a><h4 class="section"><hr>TRANSACTION FLOWS:<hr></h4>
<div class="top"><a href="http://www.mcr.org.in/sureshmudunuri/stm/unit3.php#top">TOP</a></div>
<p align="justify">
</p><ul>
   <li><b>INTRODUCTION:</b>
     <ul>
      <li>A transaction is a unit of work seen from a system user's point of view.</li>
      <li>A transaction consists of a sequence of operations, some of which are performed by a system, persons or devices that are outside of the system.</li>
      <li>Transaction begin with Birth-that is they are created as a result of some external act.</li>
      <li>At the conclusion of the transaction's processing, the transaction is no longer in the system.</li>
      <li><b>Example of a transaction:</b> A transaction for an online information retrieval system might consist of the following steps or tasks:
           <br>
           	<ul>
              <li>Accept input (tentative birth)</li>
              <li>Validate input (birth)</li>
              <li>Transmit acknowledgement to requester</li>
              <li>Do input processing</li>
              <li>Search file</li>
              <li>Request directions from user</li>
              <li>Accept input</li>
              <li>Validate input</li>
              <li>Process request</li>
              <li>Update file</li>
              <li>Transmit output</li>
              <li>Record transaction in log and clean up (death)</li>
             </ul>      
       </li>
     </ul>
     </li>
      <li><b>TRANSACTION FLOW GRAPHS:</b>
         <ul>
	        <li>Transaction flows are introduced as a representation of a system's processing.</li>
    	    <li>The methods that were applied to control flow graphs are then used for functional testing.</li>
      		<li>Transaction flows and transaction flow testing are to the independent system tester what control flows are path testing are to the programmer.</li>
      		<li>The transaction flow graph is to create a behavioral model of the program that leads to functional testing.</li>
      		<li>The transaction flowgraph is a model of the structure of the system's behavior (functionality).</li>
      		<li>An example of a Transaction Flow is as follows:
        	  <br><center><br><img src="./SOFTWARE TESTING METHODOLOGIES - ADITYA ENGINEERING COLLEGE_files/transaction_flow.jpg" border="0"><br></center><br>
              <h4 class="def" align="center">Figure 3.1: An Example of  a Transaction Flow</h4> 
      		</li>
         </ul>
      </li>
      <li><b>USAGE:</b>
         <ul>
	        <li>Transaction flows are indispensable for specifying requirements of complicated systems, especially online systems.</li>
	        <li>A big system such as an air traffic control or airline reservation system, has not hundreds, but thousands of different transaction flows.</li>
	        <li>The flows are represented by relatively simple flowgraphs, many of which have a single straight-through path.</li>
	        <li>Loops are infrequent compared to control flowgraphs.</li>
	        <li>The most common loop is used to request a retry after user input errors. An ATM system, for example, allows the user to try, say three times, and will take the card away the fourth time.</li>
         </ul>
      </li>
      <li><b>COMPLICATIONS:</b>
      <ul>
      <li>In simple cases, the transactions have a unique identity from the time they're created to the time they're completed.</li>
      <li>In many systems the transactions can give birth to others, and transactions can also merge.</li>
      <li><b>Births:</b>There are three different possible interpretations of the decision symbol, or nodes with two or more out links. It can be a Decision, Biosis or a Mitosis.
         <ol>
	        <li><b>Decision:</b>Here the transaction will take one alternative or the other alternative but not both. (See Figure 3.2 (a))</li>
	        <li><b>Biosis:</b>Here the incoming transaction gives birth to a new transaction, and both transaction continue on their separate paths, and the parent retains it identity. (See Figure 3.2 (b))</li>
	        <li><b>Mitosis:</b>Here the parent transaction is destroyed and two new transactions are created.(See Figure 3.2 (c))</li>
	     </ol>
        	  <br><center><br><img src="./SOFTWARE TESTING METHODOLOGIES - ADITYA ENGINEERING COLLEGE_files/transaction_births.jpg" border="0"><br></center><br>
              <h4 class="def" align="center">Figure 3.2: Nodes with multiple outlinks</h4> 
	     
       </li>
     <li><b>Mergers:</b>Transaction flow junction points are potentially as troublesome as transaction flow splits. There are three types of junctions: 
     (1) Ordinary Junction (2) Absorption (3) Conjugation
         <ol>
	        <li><b>Ordinary Junction:</b> An ordinary junction which is similar to the junction in a control flow graph. A transaction can arrive either on one link or the other. (See Figure 3.3 (a))</li>
	        <li><b>Absorption:</b> In absorption case, the predator transaction absorbs prey transaction. The prey gone but the predator retains its identity. (See Figure 3.3 (b))</li>
	        <li><b>Conjugation:</b> In conjugation case, the two parent transactions merge to form a new daughter. In keeping with the biological flavor this case is called as conjugation.(See Figure 3.3 (c))</li>
	     </ol>
        	  <br><center><br><img src="./SOFTWARE TESTING METHODOLOGIES - ADITYA ENGINEERING COLLEGE_files/transaction_mergers.jpg" border="0"><br></center><br>
              <h4 class="def" align="center">Figure 3.3: Transaction Flow Junctions and Mergers</h4> 
	     
       </li>
      <li>We have no problem with ordinary decisions and junctions. Births, absorptions, and conjugations are as problematic for the software designer as they are for the software modeler and the test designer; as a consequence, such points have more than their share of bugs. The common problems are: lost daughters, wrongful deaths, and illegitimate births.</li>
      </ul>
      </li>
</ul>
<p></p>
<div class="top"><a href="http://www.mcr.org.in/sureshmudunuri/stm/unit3.php#top">TOP</a></div>
 <a name="transaction_flow_techniques"></a><h4 class="section"><hr>TRANSACTION FLOW TESTING TECHNIQUES:<hr></h4>
 <div class="top"><a href="http://www.mcr.org.in/sureshmudunuri/stm/unit3.php#top">TOP</a></div>
<p align="justify">
 </p><ul>
  <li><b>GET THE TRANSACTIONS FLOWS:</b> 
         <ul>
               <li>Complicated systems that  process a lot of different, complicated transactions should have explicit representations of the transactions flows, or the equivalent.</li>
               <li>Transaction flows are like control flow graphs, and consequently we should expect to have them in increasing levels of detail.</li>
               <li>The system's design documentation should contain an overview section that details the main transaction flows.</li>
               <li>Detailed transaction flows are a mandatory pre requisite to the rational design of a system's functional test.</li>
          </ul>
  </li>     
  <li><b>INSPECTIONS, REVIEWS AND WALKTHROUGHS:</b> 
         <ul>
               <li>Transaction flows are natural agenda for system reviews or inspections.</li>
               <li>In conducting the walkthroughs, you should:
                   <ul>
                      <li>Discuss enough transaction types to account for 98%-99% of the transaction the system is expected to process.</li>
                      <li>Discuss paths through flows in functional rather than technical terms.</li>
                      <li>Ask the designers to relate every flow to the specification and to show how that transaction, directly or indirectly, follows from the requirements.</li>
                   </ul>               
               </li>
               <li>Make transaction flow testing the corner stone of system functional testing just as path testing is the corner stone of unit testing.</li>
               <li>Select additional flow paths for loops, extreme values, and domain boundaries.</li>
               <li>Design more test cases to validate all births and deaths.</li>
               <li>Publish and distribute the selected test paths through the transaction flows as early as possible so that they will exert the maximum beneficial effect on the project.</li>
               <li></li>
          </ul>
  </li>     
  <li><b>PATH SELECTION:</b> 
         <ul>
               <li>Select a set of covering paths (c1+c2) using the analogous criteria you used for structural path testing.</li>
               <li>Select a covering set of paths based on functionally sensible transactions as you would for control flow graphs.</li>
               <li>Try to find the most tortuous, longest, strangest path from the entry to the exit of the transaction flow.</li>
         </ul>
  </li>     
  <li><b>PATH SENSITIZATION:</b> 
         <ul>
               <li>Most of the normal paths are very easy to sensitize-80% - 95% transaction flow coverage (c1+c2) is usually easy to achieve.</li>
               <li>The remaining small percentage is often very difficult.</li>
               <li>Sensitization is the act of defining the transaction. If there are sensitization problems on the easy paths, then bet on either a bug in transaction flows or a design bug.</li>
         </ul>
  </li>     
  <li><b>PATH INSTRUMENTATION:</b> 
         <ul>
               <li>Instrumentation plays a bigger role in transaction flow testing than in unit path testing.</li>
               <li>The information of the path taken for a given transaction must be kept with that transaction and can be recorded by a central transaction dispatcher or by the individual processing modules.</li>
               <li>In some systems, such traces are provided by the operating systems or a running log.</li>
         </ul>
  </li>     
</ul>

<p></p>

<div class="top"><a href="http://www.mcr.org.in/sureshmudunuri/stm/unit3.php#top">TOP</a></div>
<a name="transaction_implementation"></a><h4 class="section"><hr>IMPLEMENTATION:<hr></h4>
<div class="top"><a href="http://www.mcr.org.in/sureshmudunuri/stm/unit3.php#top">TOP</a></div>
  <h4 class="def"><b>To be added</b></h4> 
<div class="top"><a href="http://www.mcr.org.in/sureshmudunuri/stm/unit3.php#top">TOP</a></div>
<a name="dataflow_testing_basics"></a><h4 class="section"><hr>BASICS OF DATA FLOW TESTING:<hr></h4>
<div class="top"><a href="http://www.mcr.org.in/sureshmudunuri/stm/unit3.php#top">TOP</a></div>
<p align="justify">
 </p><ul>
  <li><b>DATA FLOW TESTING:</b> 
         <ul>
               <li>Data flow testing is the name given to a family of test strategies based on selecting paths through the program's control flow in order to explore sequences of events related to the status of data objects.</li>
               <li>For example, pick enough paths to assure that every data object has been initialized prior to use or that all defined objects have been used for something.</li>
               <li><b>Motivation:</b>
                   <p class="def"> it is our belief that, just as one would not feel confident about a program without executing every statement in it as part of some test, one should not feel confident about a program without having seen the effect of using the value produced by each and every computation.</p>
               </li>
          </ul>
     </li>     
  <li><b>DATA FLOW MACHINES:</b> 
         <ul>
               <li>There are two types of data flow machines with different architectures. (1) Von Neumann machnes (2) Multi-instruction, multi-data machines (MIMD).</li>
               <li><b>Von Neumann  Machine  Architecture:</b>
                   <ul>
                     <li>Most computers today are von-neumann machines.</li>
                     <li>This architecture features interchangeable storage of instructions and data in the same memory units.</li>
                     <li>The Von Neumann machine Architecture executes one instruction at a time in the following, micro instruction sequence:
                           <ol>
                              <li>Fetch instruction from memory</li>
							  <li>Interpret instruction</li>
							  <li>Fetch operands</li>
							  <li>Process or Execute</li>
							  <li>Store result</li>
							  <li>Increment program counter</li>
							  <li>GOTO 1</li>
                             </ol> 
                     </li>
                 </ul>
               </li>
               <li><b>Multi-instruction, Multi-data machines (MIMD)  Architecture:</b>
                   <ul>
                     <li>These machines can fetch several instructions and objects in parallel.</li>
                     <li>They can also do arithmetic and logical operations simultaneously on different data objects.</li>
					  <li>The decision of how to sequence them depends on the compiler.</li>
                 </ul>
               </li>
          </ul>
     </li>     
  <li><b>BUG ASSUMPTION:</b> 
         <ul>
              <li>The bug assumption for data-flow testing strategies is that control flow is generally correct and that something has gone wrong with the software so that data objects are not available when they should be, or silly things are being done to data objects.</li>
              <li>Also, if there is a control-flow problem, we expect it to have symptoms that can be detected by data-flow analysis.</li>
              <li>Although we'll be doing data-flow testing, we won't be using data flowgraphs as such. Rather, we'll use an ordinary control flowgraph annotated to show what happens to the data objects of interest at the moment.</li>
          </ul>
     </li>     

  <li><b>DATA FLOW GRAPHS:</b> 
         <ul>
               <li>The data flow graph is a graph consisting of nodes and directed links.
        	  <br><center><br><img src="./SOFTWARE TESTING METHODOLOGIES - ADITYA ENGINEERING COLLEGE_files/data_flow_graph.jpg" border="0"><br></center><br>
              <h4 class="def" align="center">Figure 3.4: Example of a data flow graph</h4> 
               
               </li>
               <li>We will use an control graph to show what happens to data objects of interest at that moment.</li>
               <li>Our objective is to expose deviations between the data flows we have and the data flows we want.</li>
               <li><b>Data Object State and Usage:</b>
                    <ul>
                       <li>Data Objects can be created, killed and used.</li>
                       <li>They can be used in two distinct ways: (1) In a Calculation (2) As a part of a Control Flow Predicate.</li>
                       <li>The following symbols denote these possibilities:
                           <ol>
                            <li><b>Defined:</b> d - defined, created, initialized etc</li>
                            <li><b>Killed or undefined:</b> k - killed, undefined, released etc</li>
                            <li><b>Usage:</b> u - used for something (c - used in Calculations, p - used in a predicate)</li>
                          </ol>
                       </li>
                       <li><b>1. Defined (d):</b>
                           <ul>
                            <li>An object is defined explicitly when it appears in a data declaration.</li>
                            <li>Or implicitly when it appears on the left hand side of the assignment.</li>
                            <li>It is also to be used to mean that a file has been opened.</li>
                            <li>A dynamically allocated object has been allocated.</li>
                            <li>Something is pushed on to the stack.</li>
                            <li>A record written.</li>
                          </ul>
                       </li>
                      <li><b>2. Killed or Undefined (k):</b>
                           <ul>
                            <li>An object is killed on undefined when it is released or otherwise made unavailable.</li>
                            <li>When its contents are no longer known with certitude (with aboslute certainity / perfectness).</li>
                            <li>Release of dynamically allocated objects back to the availability pool.</li>
                            <li>Return of records.</li>
                            <li>The old top of the stack after it is popped.</li>
                            <li>An assignment statement can kill and redefine immediately. For example, if A had been previously defined and we do a new assignment such as A : = 17, we have killed A's previous value and redefined A</li>
                          </ul>
                       </li>
                      <li><b>3. Usage (u):</b>
                           <ul>
                            <li>A variable is used for computation (c) when it appears on the right hand side of an assignment statement.</li>
                            <li>A file record is read or written.</li>
                            <li>It is used in a Predicate (p) when it appears directly in a predicate.</li>
                          </ul>
                       </li>
                     </ul>
               </li>
          </ul>
     </li>     
   <li><b>DATA FLOW ANOMALIES:</b> 
         <ul>
             <li>An anomaly is denoted by a two-character sequence of actions.</li>
             <li>For example, ku means that the object is killed and then used, where as dd means that the object is defined twice without an intervening usage.</li>
             <li>What is an anomaly is depend on the application.</li>
             <li>There are nine possible two-letter combinations for d, k and u. some are bugs, some are suspicious, and some are okay.
                   <ol>
			             <li><b>dd</b> :- probably harmless but suspicious. Why define the object twice without an intervening usage?</li>
			             <li><b>dk</b> :- probably a bug. Why define the object without using it?</li>
			             <li><b>du</b> :- the normal case. The object is defined and then used.</li>
			             <li><b>kd</b> :- normal situation. An object is killed and then redefined.</li>
			             <li><b>kk</b> :- harmless but probably buggy. Did you want to be sure it was really killed?</li>
			             <li><b>ku</b> :- a bug. the object doesnot exist.</li>
			             <li><b>ud</b> :- usually not a bug because the language permits reassignment at almost any time.</li>
			             <li><b>uk</b> :- normal situation.</li>
			             <li><b>uu</b> :- normal situation.</li>
                   </ol>
             </li>
             <li>In addition to the two letter situations, there are six single letter situations.</li>
             <li>We will use a leading dash to mean that nothing of interest (d,k,u)  occurs prior to the action noted along the entry-exit path of interest.</li>
             <li>A trailing dash to mean that nothing happens after the point of interest to the exit.</li>
             <li>They possible anomalies are:
                   <ol>
			             <li><b>-k</b> :- possibly anomalous because from the entrance to this point on the path, the variable had not been defined. We are killing a variable that does not exist.</li>
			             <li><b>-d</b> :- okay. This is just the first definition along this path.</li>
			             <li><b>-u</b> :- possibly anomalous. Not anomalous if the variable is global and has been previously defined.</li>
			             <li><b>k-</b> :- not anomalous. The last thing done on this path was to kill the variable.</li>
			             <li><b>d-</b> :- possibly anomalous. The variable was defined and not used on this path. But this could be a global definition.</li>
			             <li><b>u-</b> :- not anomalous. The variable was used but not killed on this path. Although this sequence is not anomalous, it signals a frequent kind of bug. If d and k mean dynamic storage allocation and return respectively, this could be an instance in which a dynamically allocated object was not returned to the pool after use.</li>
			       </ol>
            </li>
          </ul>
     </li>     
  <li><b>DATA FLOW ANOMALY STATE GRAPH:</b> 
         <ul>
             <li>Data flow anomaly model prescribes that an object can be in one of four distinct states:
                     <ol>
			             <li><b>K</b> :- undefined, previously killed, doesnot exist</li>
			             <li><b>D</b> :- defined but not yet used for anything</li>
			             <li><b>U</b> :- has been used for computation or in predicate</li>
			             <li><b>A</b> :- anomalous</li>
			       </ol>          
             </li> 
             <li>These capital letters (K,D,U,A) denote the state of the variable and should not be confused with the program action, denoted by lower case letters.</li> 
             <li><b>Unforgiving Data - Flow Anomaly Flow Graph:</b>Unforgiving model, in which once a variable becomes anomalous it can never return to a state of grace.
        	  <br><center><br><img src="./SOFTWARE TESTING METHODOLOGIES - ADITYA ENGINEERING COLLEGE_files/unforgiving_dfag.jpg" border="0"><br></center><br>
              <h4 class="def" align="center">Figure 3.5: Unforgiving Data Flow Anomaly State Graph</h4> 
             
             Assume that the variable starts in the K state - that is, it has not been defined or does not exist. If an attempt is made to use it or to kill it (e.g., say that we're talking about 
             opening, closing, and using files and that 'killing' means closing), the object's state becomes anomalous (state A) and, once it is anomalous, no action can return the variable 
             to a working state. If it is defined (d), it goes into the D, or defined but not yet used, state. If it has been defined (D) and redefined (d) or killed without use (k), it becomes anomalous, 
             while usage (u) brings it to the U state. If in U, redefinition (d) brings it to D, u keeps it in U, and k kills it.</li> 
             <li><b>Forgiving Data - Flow Anomaly Flow Graph:</b>Forgiving model is an alternate model where redemption (recover) from the anomalous state is possible.
        	  <br><center><br><img src="./SOFTWARE TESTING METHODOLOGIES - ADITYA ENGINEERING COLLEGE_files/forgiving_dfag.jpg" border="0"><br></center><br>
              <h4 class="def" align="center">Figure 3.6: Forgiving Data Flow Anomaly State Graph</h4> 
             
            This graph has three normal and three anomalous states and he considers the kk sequence not to be anomalous. The difference between this state graph and Figure 3.5 is that 
            redemption is possible. A proper action from any of the three anomalous states returns the variable to a useful working state. 
            <br><br>The point of showing you this alternative anomaly 
            state graph is to demonstrate that the specifics of an anomaly depends on such things as language, application, context, or even your frame of mind. In principle, you must create 
            a new definition of data flow anomaly (e.g., a new state graph) in each situation. You must at least verify that the anomaly definition behind the theory or imbedded in a data flow 
            anomaly test tool is appropriate to your situation.</li>
          </ul>
     </li>     
  <li><b>STATIC Vs DYNAMIC ANOMALY DETECTION:</b> 
         <ul>
              <li>Static analysis is analysis done on source code without actually executing it. For example: source code syntax error detection is the static analysis result.</li>
              <li>Dynamic analysis is done on the fly as the program is being executed and is based on intermediate values that result from the program's execution. For example: a division by zero warning is the dynamic result.</li>
              <li>If a problem, such as a data flow anomaly, can be detected by static analysis methods, then it doesnot belongs in testing - it belongs in the language processor.</li>
              <li>There is actually a lot more static analysis for data flow analysis for data flow anomalies going on in current language processors.</li>
              <li>For example, language processors which force variable declarations can detect (-u) and (ku) anomalies.</li>
              <li>But still there are many things for which current notions of static analysis are INADEQUATE.</li>
              <li><b>Why Static Analysis isn't enough?</b> There are many things for which current notions of static analysis are inadequate. They are:
                 <ul>
                   <li><b>Dead Variables:</b>Although it is often possible to prove that a variable is dead or alive at a given point in the program, the general problem is unsolvable.</li>
                   <li><b>Arrays:</b>Arrays are problematic in that the array is defined or killed as a single object, but reference is to specific locations within the array. Array pointers 
                   are usually dynamically calculated, so there's no way to do a static analysis to validate the pointer value. In many languages, dynamically allocated arrays contain garbage 
                   unless explicitly initialized and therefore, -u anomalies are possible.</li>
                   <li><b>Records and Pointers:</b>The array problem and the difficulty with pointers is a special case of multipart data structures. We have the same problem with records 
                   and the pointers to them. Also, in many applications we create files and their names dynamically and there's no way to determine, without execution, whether such objects 
                   are in the proper state on a given path or, for that matter, whether they exist at all.</li>
                   <li><b>Dynamic Subroutine and Function Names in a Call:</b>subroutine or function name is a dynamic variable in a call. What is passed, or a combination of subroutine 
                   names and data objects, is constructed on a specific path. There's no way, without executing the path, to determine whether the call is correct or not.</li>
                   <li><b>False Anomalies:</b>Anomalies are specific to paths. Even a "clear bug" such as ku may not be a bug if the path along which the anomaly exist is unachievable. 
                   Such "anomalies" are false anomalies. Unfortunately, the problem of determining whether a path is or is not achievable is unsolvable.</li>
                   <li><b>Recoverable Anomalies and Alternate State Graphs:</b>What constitutes an anomaly depends on context, application, and semantics.
                   How does the compiler know which model I have in mind? It can't because the definition of "anomaly" is not fundamental. The language processor must have a 
                   built-in anomaly definition with which you may or may not (with good reason) agree.</li>
                   <li><b>Concurrency, Interrupts, System Issues:</b>As soon as we get away from the simple single-task uniprocessor environment and start thinking in terms of systems, 
                   most anomaly issues become vastly more complicated. How often do we define or create data objects at an interrupt level so that they can be processed by a lower-priority 
                   routine? Interrupts can make the "correct" anomalous and the "anomalous" correct. True concurrency (as in an MIMD machine) and pseudoconcurrency (as in multiprocessing) 
                   systems can do the same to us. Much of integration and system testing is aimed at detecting data-flow anomalies that cannot be detected in the context of a single routine.</li>
                 </ul>
              </li>
              <li>Although static analysis methods have limits, they are worth using and a continuing trend in language processor design has been better static analysis methods, especially for data flow anomaly detection. 
              That's good because it means there's less for us to do as testers and we have far too much to do as it is.</li>
          </ul>
     </li>     
    <li><b>DATA FLOW MODEL:</b> 
         <ul>
              <li>The data flow model is based on the program's control flow graph - Don't confuse that with the program's data flowgraph..</li>
              <li>Here we annotate each link with symbols (for example, d, k, u, c, p) or sequences of symbols (for example, dd, du, ddd) that denote the sequence of data operations on that link with respect to the variable 
              of interest. Such annotations are called link weights.</li>
              <li>The control flow graph structure is same for every variable: it is the weights that change.</li>
              <li><b>Components of the model:</b>
                <ol>
                 <li>To every statement there is a node, whose name is unique. Every node has at least one outlink and at least one inlink except for exit nodes and entry nodes.</li>
                 <li>Exit nodes are dummy nodes placed at the outgoing arrowheads of exit statements (e.g., END, RETURN), to complete the graph. Similarly, entry nodes are dummy nodes placed at entry statements (e.g., BEGIN) for the same reason.</li>
                 <li>The outlink of simple statements (statements with only one outlink) are weighted by the proper sequence of data-flow actions for that statement. Note that the sequence can consist of more than one letter. For example, the assignment 
                 statement A:= A + B in most languages is weighted by cd or possibly ckd for variable A. Languages that permit multiple simultaneous assignments and/or compound statements can have anomalies within the statement. The sequence must 
                 correspond to the order in which the object code will be executed for that variable.</li>
                 <li>Predicate nodes (e.g., IF-THEN-ELSE, DO WHILE, CASE) are weighted with the p - use(s) on every outlink, appropriate to that outlink.</li>
                 <li>Every sequence of simple statements (e.g., a sequence of nodes with one inlink and one outlink) can be replaced by a pair of nodes that has, as weights on the link between them, the concatenation of link weights.</li>
                 <li>If there are several data-flow actions on a given link for a given variable, then the weight of the link is denoted by the sequence of actions on that link for that variable.</li>
                 <li>Conversely, a link with several data-flow actions on it can be replaced by a succession of equivalent links, each of which has at most one data-flow action for any variable.</li>
               </ol>
              </li>
              <li>Let us consider the example:
                  <center><br><br><img src="./SOFTWARE TESTING METHODOLOGIES - ADITYA ENGINEERING COLLEGE_files/pdl_example.jpg" border="0"> <br></center><br>
                  <h4 class="def" align="center">Figure 3.7: Program Example (PDL)</h4> <hr>
                  <center><br><br><img src="./SOFTWARE TESTING METHODOLOGIES - ADITYA ENGINEERING COLLEGE_files/unannotated_flowgraph.jpg" border="0"> <br></center><br>
                  <h4 class="def" align="center">Figure 3.8: Unannotated flowgraph for example program in Figure 3.7</h4><hr> 
                  <center><br><br><img src="./SOFTWARE TESTING METHODOLOGIES - ADITYA ENGINEERING COLLEGE_files/annotated_flowgraph_x.jpg" border="0"> <br></center><br>
                  <h4 class="def" align="center">Figure 3.9: Control flowgraph annotated for X and Y data flows.</h4><hr> 
                  <center><br><br><img src="./SOFTWARE TESTING METHODOLOGIES - ADITYA ENGINEERING COLLEGE_files/annotated_flowgraph_z.jpg" border="0"> <br></center><br>
                  <h4 class="def" align="center">Figure 3.10: Control flowgraph annotated for Z data flow.</h4><hr> 
                  <center><br><br><img src="./SOFTWARE TESTING METHODOLOGIES - ADITYA ENGINEERING COLLEGE_files/annotated_flowgraph_v.jpg" border="0"> <br></center><br>
                  <h4 class="def" align="center">Figure 3.11: Control flowgraph annotated for V data flow.</h4><hr> 
              </li>
          </ul>
     </li>     
 </ul>
 <p></p>
<div class="top"><a href="http://www.mcr.org.in/sureshmudunuri/stm/unit3.php#top">TOP</a></div>
<a name="strategies_dft"></a><h4 class="section"><hr>STRATEGIES OF DATA FLOW TESTING:<hr></h4>
<div class="top"><a href="http://www.mcr.org.in/sureshmudunuri/stm/unit3.php#top">TOP</a></div>
<ul>
  <li><b>INTRODUCTION:</b> 
         <ul>
              <li>Data Flow Testing Strategies are structural strategies.</li>
              <li>In contrast to the path-testing strategies, data-flow strategies take into account what happens to data objects on the links in addition to the raw connectivity  of the graph.</li> 
              <li>In other words, data flow strategies require data-flow link weights (d,k,u,c,p).</li>
              <li>Data Flow Testing Strategies are based on selecting test path segments (also called <b>sub paths</b>) that satisfy some characteristic of data flows for all data objects.</li>
              <li>For example, all subpaths that contain a d (or u, k, du, dk).</li>
              <li>A strategy X is <b>stronger</b> than another strategy Y if all test cases produced under Y are included in those produced under X - conversely for <b>weaker</b>.</li>
          </ul>
     </li>     
  <li><b>TERMINOLOGY:</b> 
         <ol>
              <li><b>Definition-Clear Path Segment</b>, with respect to variable X, is a connected sequence of links such that X is (possibly) defined on the first link and not redefined or 
              killed on any subsequent link of that path segment. ll paths in Figure 3.9 are definition clear because variables X and Y are defined only on the first link (1,3) and not thereafter.
              In Figure 3.10, we have a more complicated situation. The following path segments are definition-clear: (1,3,4), (1,3,5), (5,6,7,4), (7,8,9,6,7), 
              (7,8,9,10), (7,8,10), (7,8,10,11). Subpath (1,3,4,5) is not definition-clear because the variable is defined on (1,3) and again on (4,5). For practice, try finding all the definition-clear 
              subpaths for this routine (i.e., for all variables).</li>
              <li><b>Loop-Free Path Segment</b> is a path segment for which every node in it is visited atmost once. For Example, path (4,5,6,7,8,10) in Figure 3.10 is loop free, 
              but path (10,11,4,5,6,7,8,10,11,12) is not because nodes 10 and 11 are each visited twice.</li>
              <li><b>Simple path segment</b> is a path segment in which at most one node is visited twice. For example, in Figure 3.10, (7,4,5,6,7) is a simple path segment. 
              A simple path segment is either loop-free or if there is a loop, only one node is involved.</li>
              <li>A <b>du path</b> from node i to k is a path segment such that if the last link has a computational use of X, then the path is simple and definition-clear; 
              if the penultimate (last but one) node is j - that is, the path is (i,p,q,...,r,s,t,j,k) and link (j,k) has a predicate use - then the path from i to j is both loop-free and definition-clear.</li>
          </ol>
     </li>     
  <li><b>STRATEGIES:</b> The structural test strategies discussed below are based on the program's control flowgraph. 
  They differ in the extent to which predicate uses and/or computational uses of variables are included in the test set.
  Various types of data flow testing strategies in decreasing order of their effectiveness are:
  <br><br>
         <ol>
              <li><b><font color="#A00000">All - du Paths (ADUP):</font></b> The all-du-paths (ADUP) strategy is the strongest data-flow testing strategy discussed here. It requires that every du path from every 
              definition of every variable to every use of that definition be exercised under some test.<br><br>
              
              <b><i>For variable X and Y:</i></b>In Figure 3.9, because variables X and Y are used only on link (1,3), any test that starts at the entry satisfies this criterion (for variables X and Y, but not for all 
              variables as required by the strategy). 
              <br><br>
              <b><i>For variable Z:</i></b> The situation for variable Z (Figure 3.10) is more complicated because the variable is redefined in many places. 
              For the definition on link (1,3) we must exercise paths that include subpaths (1,3,4) and (1,3,5). The definition on link (4,5) is covered by any path that includes (5,6), 
              such as subpath (1,3,4,5,6, ...). The (5,6) definition requires paths that include subpaths (5,6,7,4) and (5,6,7,8).
              <br><br>
              <b><i>For variable V:</i></b> Variable V (Figure 3.11) is defined only once on link (1,3). Because V has a predicate use at node 12 and the subsequent path to the end must be forced for both directions at node 12, 
              the all-du-paths strategy for this variable requires that we exercise all loop-free entry/exit paths and at least one path that includes the loop caused by (11,4). Note that we must test paths 
              that include both subpaths (3,4,5) and (3,5) even though neither of these has V definitions. They must be included because they provide alternate du paths to the V use on link (5,6). 
              Although (7,4) is not used in the test set for variable V, it will be included in the test set that covers the predicate uses of array variable V() and U.
              <br><br>
             The all-du-paths strategy is a strong criterion, but it does not take as many tests as it might seem at first because any one test simultaneously satisfies the criterion for 
              several definitions and uses of several different variables.
              <br><br></li>
              <li><b><font color="#A00000">All Uses Startegy (AU):</font></b>The all uses strategy is that at least one definition clear path from every definition of every variable to every use of that  definition be exercised under some test.
              Just as we reduced our ambitions by stepping down from all paths (P) to branch coverage (C2), say, we can reduce the number of test cases by asking that the test set should include at least 
              one path segment from every definition to every use that can be reached by that definition.
              <br><br>
              <b><i>For variable V:</i></b> In Figure 3.11, ADUP requires that we include subpaths (3,4,5) and (3,5) in some test because subsequent uses of V, such as on link (5,6), can be reached by either alternative. 
              In AU either (3,4,5) or (3,5) can be used to start paths, but we don't have to use both. Similarly, we can skip the (8,10) link if we've included the (8,9,10) subpath. 
              Note the hole. We must include (8,9,10) in some test cases because that's the only way to reach the c use at link (9,10) - but suppose our bug for variable V is on link (8,10) after all? 
              Find a covering set of paths under AU for Figure 3.11.
              <br><br>
              </li>
              <li><b><font color="#A00000">All p-uses/some c-uses strategy (APU+C) :</font></b> For every variable and every definition of that variable, include at least one definition free path from the definition to every predicate use; 
              if there are definitions of the variables that are not covered by the above prescription, then add computational use test cases as required to cover every definition.
              <br><br>
              <b><i>For variable Z:</i></b>In Figure 3.10, for APU+C we can select paths that all take the upper link (12,13) and therefore we do not cover the c-use of Z: 
              but that's okay according to the strategy's definition because every definition is covered. Links (1,3), (4,5), (5,6), and (7,8) must be included because they contain definitions for variable Z. 
              Links (3,4), (3,5), (8,9), (8,10), (9,6), and (9,10) must be included because they contain predicate uses of Z. 
              Find a covering set of test cases under APU+C for all variables in this example - it only takes two tests.
              <br><br>
              <b><i>For variable V:</i></b>In Figure 3.11, APU+C is achieved for V by (1,3,5,6,7,8,10,11,4,5,6,7,8,10,11,12[upper], 13,2) and (1,3,5,6,7,8,10,11,12[lower], 13,2). 
              Note that the c-use at (9,10) need not be included under the APU+C criterion.
              <br><br>
              </li>
              <li><b><font color="#A00000">All c-uses/some p-uses strategy (ACU+P) :</font></b> The all c-uses/some p-uses strategy (ACU+P) is to first ensure coverage by computational use cases and 
              if any definition is not covered by the previously selected paths, add such predicate use cases as are needed to assure that every definition is included in some test.
              <br><br>
              <b><i>For variable Z:</i></b> In Figure 3.10, ACU+P coverage is achieved for Z by path (1,3,4,5,6,7,8,10, 11,12,13[lower], 2), but the predicate uses of several definitions are not covered. 
              Specifically, the (1,3) definition is not covered for the (3,5) p-use, the (7,8) definition is not covered for the (8,9), (9,6) and (9, 10) p-uses.
              <br><br>
              <p class="def">The above examples imply that APU+C is stronger than branch coverage but ACU+P may be weaker than, or incomparable to, branch coverage.</p>
              </li>
              <li><b><font color="#A00000">All Definitions Strategy (AD) :</font></b> The all definitions strategy asks only every definition of every variable be covered by atleast one use of that variable, 
              be that use a computational use or a predicate use.
              <br><br>
             <b><i>For variable Z:</i></b> Path (1,3,4,5,6,7,8, . . .) satisfies this criterion for variable Z, whereas any entry/exit path satisfies it for variable V. 
             <br><br>
             <p class="def">From the definition of this strategy we would expect it to be weaker than both ACU+P and APU+C. </p>
             </li>
             <li><b><font color="#A00000">All Predicate  Uses (APU), All Computational Uses (ACU) Strategies :</font></b> The all predicate uses strategy is derived from APU+C strategy by dropping the 
             requirement that we include a c-use for the variable if there are no p-uses for the variable. The all computational uses strategy is derived from ACU+P strategy by dropping the requirement that 
             we include a p-use for the variable if there are no c-uses for the variable.
              <br><br>
              <p class="def">It is intuitively obvious that ACU should be weaker than ACU+P and that APU should be weaker than APU+C.</p>
             </li>
          </ol>
     </li>     
  <li><b>ORDERING THE STRATEGIES:</b> 
         <ul>
				<li>Figure 3.12 compares path-flow and data-flow testing strategies. The arrows denote that the strategy at the arrow's tail is stronger than the strategy at the arrow's head.
	             <center><br><br><img src="./SOFTWARE TESTING METHODOLOGIES - ADITYA ENGINEERING COLLEGE_files/strategies_dft.jpg" border="1"> <br></center><br>
                 <h4 class="def" align="center">Figure 3.12: Relative Strength of Structural Test Strategies.</h4> 
    			</li>
				<li>The right-hand side of this graph, along the path from "all paths" to "all statements" is the more interesting hierarchy for practical applications.</li>
				<li>Note that although ACU+P is stronger than ACU, both are incomparable to the predicate-biased strategies. Note also that "all definitions" is not comparable to ACU or APU.</li>
          </ul>
     </li>     
  <li><b>SLICING AND DICING:</b> 
         <ul>
				<li>A (static) program <b>slice</b> is a part of a program (e.g., a selected set of statements) defined with respect to a given variable X (where X is a simple variable or a data vector) and a statement i:
				it is the set of all statements that could (potentially, under static analysis) affect the value of X at statement i - where the influence of a faulty statement could result from an improper computational use 
				or predicate use of some other variables at prior statements.</li>
				<li>If X is incorrect at statement i, it follows that the bug must be in the program slice for X with respect to i</li>
				<li>A program <b>dice</b> is a part of a slice in which all statements which are known to be correct have been removed.</li>
				<li>In other words, a dice is obtained from a slice by incorporating information obtained through testing or experiment (e.g., debugging).</li>
				<li>The debugger first limits her scope to those prior statements that could have caused the faulty value at statement i (the slice) and then eliminates from further consideration those statements that testing has shown to be correct.</li>
				<li>Debugging can be modeled as an iterative procedure in which slices are further refined by dicing, where the dicing information is obtained from ad hoc tests aimed primarily at eliminating possibilities. 
				Debugging ends when the dice has been reduced to the one faulty statement.</li>
				<li><b>Dynamic slicing</b> is a refinement of static slicing in which only statements on achievable paths to the statement in question are included.</li>
          </ul>
     </li>     


</ul>
<div class="top"><a href="http://www.mcr.org.in/sureshmudunuri/stm/unit3.php#top">TOP</a></div>
<a name="application_dft"></a><h4 class="section"><hr>APPLICATION OF DATA FLOW TESTING:<hr></h4>
<div class="top"><a href="http://www.mcr.org.in/sureshmudunuri/stm/unit3.php#top">TOP</a></div>
  <h4 class="def"><b>To be added</b></h4> 

<div class="top"><a href="http://www.mcr.org.in/sureshmudunuri/stm/unit3.php#top">TOP</a></div>
<a name="summary"></a><h4 class="section"><hr>SUMMARY:<hr></h4>
<div class="top"><a href="http://www.mcr.org.in/sureshmudunuri/stm/unit3.php#top">TOP</a></div>
<p align="justify">
</p><ul>
  <li>The methods discussed for path testing of units and programs can be applied with suitable interpretation to functional testing based on transaction flows.</li>
  <li>The biggest problem and the biggest payoff may be getting the transaction flows in the first place.</li>
  <li>Full coverage (C1 + C2) is required for all flows, but most bugs will be found on the strange, meaningless, weird paths.</li>
  <li>Transaction-flow control may be implemented by means of an undeclared and unrecognized internal language.</li>
  <li>The practice of attempting to design tests based on transaction-flow representation of requirements and discussing those attempts with the designer can unearth more bugs than any tests you run.</li>
  <li>Data are as important as code and will become more important.</li>
  <li>Data integrity is as important as code integrity. Just as common sense dictates that all statements and branches be exercised on under test, all data definitions and subsequent uses must similarly be tested.</li>
  <li>What constitutes a data flow anomaly is peculiar to the application. Be sure to have a clear concept of data flow anomalies in your situation.</li>
  <li>Use all available tools to detect those anomalies that can be detected statically. Let the extent and excellence of static data-flow anomaly detection be as important a criterion in selecting a language processor 
  as produced object code efficiency and compilation speed. Use the slower compiler that gives you slower object code if it can detect more anomalies. You can always recompile the unit after it has been debugged.</li>
  <li>The data-flow testing strategies span the gap between all paths and branch testing. Of the various available strategies, AU probably has the best payoff for the money. It seems to be no worse than twice the number 
  of test cases required for branch testing, but the resulting code is much more reliable. AU is not too difficult to do without supporting tools, but use the tools as they become available.</li>
  <li>Don't restrict your notion of data-flow anomaly to the obvious. The symbols d, k, u, and the associated anomalies, can be interpreted (with profit) in terms of file opening and closing, resource management, and other applications.</li>
</ul>
<p></p>
<div class="top"><a href="http://www.mcr.org.in/sureshmudunuri/stm/unit3.php#top">TOP</a></div>
<hr><br><br><br>
<br><br><br><br>

</td>
</tr>
<!-- END CONTENT SECTION -->
</tbody></table></td></tr></tbody></table>
</td></tr><tr><td>
<table border="0" bordercolor="blue" width="100%" height="55" bgcolor="#2E8B57">
<tbody><tr><td>
<center><font color="ffffff" size="2"> 2010 <a href="http://www.mcr.org.in/sureshmudunuri/" target="stm"><font color="orange">Suresh Babu Mudunuri</font></a>, Associate Professor, Aditya Engineering College</font></center>
</td></tr>
<tr></tr></tbody></table> 

</td></tr></tbody>
</table>
</font>

</body></html>